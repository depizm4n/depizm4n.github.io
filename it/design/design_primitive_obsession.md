# Primitive Obsession

変数の型を基本型で定めるアンチパターン。

## なぜ問題か
### 1. 型から仕様が流出する
このコードは、関数の利用側に引数の検証処理を強制できないという問題がある。

```ts
// この関数を呼び出す前に `validTelephoneNumber` を呼んでください
function ring(telephoneNumber: string) {
    // 
}
```

このほかに、  
- コメントを見ないといつ検証処理を行うべきか判断できない
- 呼び出し側で検証処理が散乱する
- 類似の電話番号を引数に持つ箇所も同様の実装になる

と、保守性に欠ける構成になる。

これは基本型で割り当てることによりデータの特徴を型に閉じ込められず、  
その特徴を利用側で実装することに起きるのが原因である。

### 2. 型の表現力が喪失する
変数や関数がどのような役割を果たすかを、その名前で表現することがしばしばある。  
こと変数においては、その型を活用することでも表現することができる。

その際に基本型で表現することで、データの特徴を表現することができないという欠点がある。

## TypeScriptにおけるユースケース
### 1. 値を取る候補が有限個の場合 ⇒ ユニオン型を活用する
列挙型のように、値を取る候補が有限後の場合はユニオン型を活用する。  
また、テンプレートリテラル型を併用することもある。

### 2. 既存のデータ構造を参照する ⇒ Mapped Typesや型演算子を活用する
型演算子やMapped Typesは既存のデータ構造を参照することで型の二重管理を脱却できるが、  
特定のデータ型を参照していると表明することで、型の表現力を獲得するというメリットがある。

### 3. 型に仕様を込める
ケースバイケースのため、出現頻度が高いものを取り上げる。

#### 3-1. 公称型を実現する ⇒ Branded Typeで実装する
値オブジェクトを作成する方法もあるが、  
TypeScriptではBranded Typeにより実装できる。

```ts
declare const nomialTelephoneNumber: unique symbol;
type TelephoneNumber = string & {[nomialTelephoneNumber]: never};
```

この場合、コンパニオンオブジェクトを活用したインスタンスを戻る関数を利用するタイプと、  
ユーザー型定義ガード関数を利用するタイプと2通りある。

後者の場合、
- 検証処理をパスできない場合を柔軟に記述できる
- JavaScriptに検証処理が出力される

という点で軍配が上がる。

> ⚡   
> 条件型を駆使して実現した場合、JavaScriptに出力されない

#### 3-2. パターン2 & 動的な型を割り当てる ⇒ 条件型、型引数の制約を活用する
データ構造を参照しながらジェネリクスを実現する場合のケースに該当する。

```ts
function callback<Func extends (...params: any[]) => any>(
    fn: Func,
    ...params: Paramters<Func>
): ReturnType<Func> {
    return fn(params);
}
```

#### 3-3. エッジケースを明示する ⇒ 条件型を活用する
空文字でない文字列型、空配列でない配列型、非null/null許容を表明するケースに該当する。

```ts
type Code<S extends string> =
    S extends `${infer L}${infer R}`
    ? L extends ''
        ? never
        : S
    : never;
```

#### 3-4. 柔軟な型ユーティリティを利用する ⇒ Key Remapping を活用する
既存の型ユーティリティでは実現できない場合に `Key Remapping` を活用する。  
キー名を解析する場合は `infer` キーワードも併用する。
